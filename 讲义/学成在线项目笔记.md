## Day1

```java
@RestController //响应json数据，相当于@Controller和@ResponseBody
public class CourseBaseInfoController {
    @RequestMapping("/course/list")
    public PageResult<CourseBase> list(PageParams pageParams, @RequestBody QueryCourseParamsDto queryCourseParams){

        return null;

    }

}
```



`@RestController` 是 Spring 框架中的一个注解，它的作用是将一个类标记为 RESTful 服务的控制器。在 Spring MVC 中，`@RestController` 注解用于标识一个类，这个类中的方法返回的对象直接写入 HTTP 响应体中，通常用于构建 RESTful API。

与 `@Controller` 注解不同的是，`@RestController` 注解不需要在每个方法上添加 `@ResponseBody` 注解来指示返回的对象要写入响应体中。这样可以简化代码，提高开发效率。



`@RequestMapping` 是 Spring MVC 中用来映射 HTTP 请求到具体处理方法的注解。它可以用在控制器类或者控制器方法上。

1. **在类级别使用 `@RequestMapping`**：可以定义处理类中所有请求的基本 URL。例如，如果你在类上使用 `@RequestMapping("/users")`，那么这个控制器中的所有方法处理的请求都会以 "/users" 开头。
2. **在方法级别使用 `@RequestMapping`**：可以定义特定请求路径的处理方法。你可以指定请求的 URL、HTTP 方法、请求参数等信息。例如，`@RequestMapping(value="/user/{id}", method=RequestMethod.GET)` 指示了处理 GET 请求，并且 URL 中的 `{id}` 参数将会作为方法参数被传递。

`@RequestMapping` 注解提供了很大的灵活性，可以根据项目的需求精确地映射 HTTP 请求到相应的处理方法上。



`@RequestBody` 是 Spring MVC 中的一个注解，它用于指示框架将 HTTP 请求体的内容绑定到一个特定的对象上。当你在控制器方法的参数上添加 `@RequestBody` 注解时，Spring MVC 将会尝试从 HTTP 请求中获取请求体的内容，并尝试将这些内容转换成你所指定的对象类型。这样你就可以直接在控制器方法中使用这个对象来处理请求中的数据，而不需要手动解析 HTTP 请求。



```java
@SpringBootApplication
public class ContentApplication {
    public static void main(String[] args) {
        SpringApplication.run(ContentApplication.class, args);
    }
}
```

这个类是一个典型的 Spring Boot 应用程序的启动类。它的作用是启动 Spring Boot 应用程序。在这个类中，`main` 方法调用了 `SpringApplication.run()` 方法，并传入了应用程序的主类 `ContentApplication.class` 和命令行参数 `args`。这样做会启动 Spring Boot 应用程序，并且 Spring Boot 将会自动扫描并加载应用程序中的所有组件，并启动嵌入式的 Servlet 容器（例如 Tomcat），从而使应用程序可以处理 HTTP 请求。

简单来说，这个类的作用就是启动 Spring Boot 应用程序，让它开始运行。





## Day2

** Wrapper和LamdaQueryWrapper的区别？**

`Wrapper` 和 `LambdaQueryWrapper` 都是 MyBatis-Plus 中用于构建条件查询的工具，它们的区别主要在于构建查询条件的方式和使用方法：

1. **Wrapper**：
   - `Wrapper` 是一个抽象类，用于构建条件查询。
   - 它提供了一系列方法来构建条件，比如 `eq`、`ne`、`in`、`like` 等。
   - 使用 `Wrapper` 时，通常需要在方法中传入实体类的属性名作为参数，例如 `eq("name", "value")`，其中 `"name"` 是实体类的属性名，`"value"` 是要匹配的值。
2. **LambdaQueryWrapper**：
   - `LambdaQueryWrapper` 是 `Wrapper` 的一个实现，它使用了 Lambda 表达式来构建查询条件。
   - 使用 `LambdaQueryWrapper` 可以通过 Lambda 表达式来指定查询条件，使得代码更加简洁和易读。
   - 在使用 `LambdaQueryWrapper` 时，可以直接在 Lambda 表达式中引用实体类的属性，无需指定属性名，例如 `wrapper.lambda().eq(Entity::getName, "value")`，其中 `Entity::getName` 是实体类的属性，`"value"` 是要匹配的值。

总的来说，`LambdaQueryWrapper` 提供了一种更加简洁和方便的方式来构建查询条件，特别是在使用 Lambda 表达式时可以使得代码更加清晰易懂。





**在mybatis中，mapper接口文件对应的.xml文件是干什么用的**


在 MyBatis 中，Mapper 接口文件对应的 `.xml` 文件是用来定义 SQL 映射语句的。这个 `.xml` 文件通常被称为 Mapper XML 文件或者映射文件。

Mapper 接口文件定义了一系列的方法，每个方法都对应着一个 SQL 查询、插入、更新或删除操作。这些方法通过注解（如 `@Select`、`@Insert`、`@Update`、`@Delete` 等）来指定对应的 SQL 语句。然后，MyBatis 将会根据这些注解生成代理类，从而实现对数据库的操作。

而 `.xml` 文件则提供了更灵活的方式来定义 SQL 语句。在这个文件中，你可以使用 XML 标签来编写 SQL 语句，包括 `select`、`insert`、`update`、`delete` 等标签。这些标签可以嵌套使用，并且支持动态 SQL（如 `if`、`choose`、`foreach` 等）和参数映射。

通常情况下，Mapper 接口文件和对应的 `.xml` 文件是一一对应的关系，每个方法在 Mapper 接口文件中都会有对应的 SQL 语句在 `.xml` 文件中定义。在运行时，MyBatis 会根据 Mapper 接口文件和 `.xml` 文件中的配置来执行对应的 SQL 语句，并将结果映射为 Java 对象返回。



**也就是说，我可以不用注解里的@Select来查询数据，而是可以在.xml文件中写自己的查询数据的逻辑 对嘛？**

是的，你可以不使用注解，在 XML 文件中编写自己的查询数据的逻辑。这是 MyBatis 的一个特性，允许你使用 XML 文件来定义 SQL 映射语句和查询逻辑。

在 XML 文件中，你可以使用 `<select>` 标签来定义查询语句。这个标签包含了 SQL 查询语句，以及一些其他的配置项，比如参数映射、结果映射等。使用 XML 文件编写查询语句的好处是可以提高灵活性和可维护性，特别是对于一些复杂的 SQL 查询语句或者需要动态拼接 SQL 的场景。

下面是一个使用 XML 文件定义查询语句的示例：

```xml
xmlCopy code<!-- 定义查询语句 -->
<select id="getUserById" resultType="com.example.User">
    SELECT * FROM user WHERE id = #{id}
</select>
```

在上面的示例中，`<select>` 标签定义了一个查询语句，通过 `id` 属性指定了查询语句的唯一标识符，通过 `resultType` 属性指定了查询结果的映射类型，然后在标签内部编写了具体的 SQL 查询语句。

在 Mapper 接口中，你可以通过方法名和 XML 文件中的查询语句的唯一标识符来映射到对应的查询语句。例如：

```xml
javaCopy codepublic interface UserMapper {
    User getUserById(Long id);
}
```

在运行时，MyBatis 会根据 Mapper 接口中的方法名和 XML 文件中的查询语句的唯一标识符来执行对应的 SQL 查询，并将结果映射为 `User` 类型的对象返回。



**那我如果直接使用注解，是不是就不用定义.xml文件了?**

是的，如果你选择使用注解来定义 SQL 查询语句，就不需要再编写 XML 文件了。MyBatis 提供了一系列的注解（如 `@Select`、`@Insert`、`@Update`、`@Delete` 等）来定义 SQL 查询、插入、更新、删除操作，你可以直接在 Mapper 接口中使用这些注解来编写 SQL 语句。

使用注解可以更加直观地将 SQL 查询语句与 Java 方法关联起来，简化了配置和管理，尤其是对于一些简单的查询操作来说，使用注解是一种更加方便的方式。

以下是一个使用注解定义查询语句的示例：

```
javaCopy codepublic interface UserMapper {
    @Select("SELECT * FROM user WHERE id = #{id}")
    User getUserById(Long id);
}
```

在上面的示例中，通过 `@Select` 注解直接在接口方法上定义了查询语句，而不需要额外的 XML 文件。在运行时，MyBatis 会根据注解中定义的 SQL 查询语句执行对应的操作，并将结果映射为相应的 Java 对象返回。



### 异常处理

***@ExceptionHandler(XueChengPlusException.class)该注解有什么含义？***

`@ExceptionHandler(XueChengPlusException.class)` 是 Spring 框架中用于处理异常的注解之一。具体来说，它的含义是：

- `@ExceptionHandler` 注解用于在 Spring MVC 控制器中定义异常处理方法。当控制器中的某个方法抛出指定类型的异常时，Spring 将会调用带有 `@ExceptionHandler` 注解的异常处理方法来处理这个异常。
- `XueChengPlusException.class` 是指定了要处理的异常类型。在这个例子中，`XueChengPlusException` 是自定义的异常类，该注解表示当抛出 `XueChengPlusException` 异常时，会调用被注解的方法来处理该异常。

例如：

```java
javaCopy code@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(XueChengPlusException.class)
    public ResponseEntity<ErrorResponse> handleXueChengPlusException(XueChengPlusException ex) {
        // 处理异常逻辑
    }
}
```

在上面的代码中，`handleXueChengPlusException` 方法用于处理 `XueChengPlusException` 异常。当控制器中的某个方法抛出 `XueChengPlusException` 异常时，Spring 将会调用该方法来处理异常。

```java
package com.xuecheng.base.exception;

import java.io.Serializable;

/**
 * 和前端约定返回的异常信息模型
 * 和前端约定返回的异常信息都为json，json的属性为errMessage
 */
public class RestErrorResponse implements Serializable {

    private String errMessage; //给前端的错误信息

    public RestErrorResponse(String errMessage){
        this.errMessage= errMessage;
    }

    public String getErrMessage() {
        return errMessage;
    }

    public void setErrMessage(String errMessage) {
        this.errMessage = errMessage;
    }
} 
```

***上述类有什么作用？***

这个类是用来定义在与前端通信时返回异常信息的数据模型。在与前端进行数据交互时，异常信息通常以 JSON 格式返回，而这个类就定义了这个 JSON 数据模型的结构。

具体来说：

- `RestErrorResponse` 类有一个属性 `errMessage`，用于存储错误信息。
- 该类提供了一个构造方法和相应的 getter 和 setter 方法，用于设置和获取 `errMessage` 属性的值。
- 在与前端交互时，当出现异常时，可以创建一个 `RestErrorResponse` 对象，并将异常信息设置为 `errMessage` 属性的值，然后以 JSON 格式返回给前端，使得前端能够得到错误信息并进行相应的处理。

总之，这个类的作用就是定义了在与前端交互时返回异常信息的数据结构，以便前端能够获取到异常信息并进行处理。

***怎么看出这个类是返回一个json格式的数据，是因为Serializable吗？***

`Serializable` 接口是 Java 中的一个标记接口，用于表示一个类的对象可以被序列化，即可以被转换成字节流并在网络上传输或者持久化到磁盘中。在 Spring Boot 中，通常情况下，当控制器方法返回一个对象时，Spring Boot 会自动将其转换为 JSON 格式的数据返回给客户端。

虽然 `Serializable` 接口本身与 JSON 格式无关，但在 Spring Boot 中，通常一个需要返回 JSON 格式数据的类都会实现 `Serializable` 接口。这是因为在 Java 中，大多数情况下，如果一个类实现了 `Serializable` 接口，那么该类的对象就可以被序列化，包括被转换成 JSON 格式的数据。

因此，当一个类实现了 `Serializable` 接口时，很可能会被用于返回 JSON 格式的数据。但需要注意的是，并不是所有实现了 `Serializable` 接口的类都会被用于返回 JSON 格式的数据，这取决于类的具体用途和在 Spring Boot 应用中的配置。

***抛出异常和处理异常有什么区别？***

抛出异常和处理异常是两个不同的概念，它们在异常处理中扮演着不同的角色：

1. **抛出异常**：
   - 抛出异常是指在代码执行过程中遇到错误或异常情况时，程序员主动抛出（throw）一个异常对象。
   - 当某个方法内部发生了异常情况，但该方法无法处理该异常时，通常会选择将异常抛出到调用方，由调用方来处理异常。
   - 通过 `throw` 关键字可以抛出一个异常对象，将控制权转交给调用方或者上层调用链。
   - 抛出异常的目的是告知调用方发生了异常，并且传递异常的信息，以便调用方能够适当地处理异常。
2. **处理异常**：
   - 处理异常是指在代码中针对异常情况进行处理，以避免程序终止或者提供更友好的用户体验。
   - 异常处理通常通过 `try-catch` 块来实现，即将可能抛出异常的代码放置在 `try` 块中，然后在 `catch` 块中捕获并处理异常。
   - 处理异常的目的是在异常发生时提供一种应对措施，使程序能够继续执行下去，而不是因为异常而终止。

总的来说，抛出异常是在方法内部遇到无法处理的异常情况时将异常传递给调用方，而处理异常则是在调用方接收到异常后进行适当的处理，以保证程序的正常执行。抛出异常和处理异常是异常处理机制的两个重要组成部分，它们共同构成了异常处理的完整流程。



```java
@Slf4j
@ControllerAdvice
public class GlobalExceptionHandler {
// 对项目的自定义异常进行处理(属于系统自定义异常)
    @ResponseBody // 返回json格式
    @ExceptionHandler(XueChengPlusException.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) //遇到异常信息后，响应给前端的状态码
    public RestErrorResponse customException(XueChengPlusException e) {
        //记录异常日志
        log.error("系统异常{}",e.getErrMessage(),e);
        // 解析出异常信息
        String errMessage = e.getErrMessage();
        RestErrorResponse restErrorResponse = new RestErrorResponse(errMessage);
        return restErrorResponse;
//        log.error("【系统异常】{}",e.getErrMessage(),e);
//        return new RestErrorResponse(e.getErrMessage());

    }


// 针对不是系统自定义的异常,比如说网络断了,或者一个分数的分母为0
    @ResponseBody
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public RestErrorResponse exception(Exception e) {
        //记录异常日志
        log.error("系统异常{}",e.getMessage(),e);
        // 解析出异常信息
        RestErrorResponse restErrorResponse = new RestErrorResponse(CommonError.UNKOWN_ERROR.getErrMessage()); //异常信息： "执行过程异常，请重试。"
        return restErrorResponse;
    }
}
```

***上面代码中，@ControllerAdvice该注解的作用是什么?***

`@ControllerAdvice` 是 Spring MVC 中的一个注解，它的作用是全局性地统一处理控制器（Controller）的异常。具体来说，`@ControllerAdvice` 注解的作用包括：

1. **全局异常处理**：通过在 `@ControllerAdvice` 注解标注的类中定义异常处理方法，可以统一捕获并处理控制器中抛出的异常。这样可以避免在每个控制器中都编写相同的异常处理逻辑，提高代码的复用性和可维护性。
2. **全局数据绑定**：`@ControllerAdvice` 注解的类中还可以定义全局数据绑定逻辑，例如将请求参数绑定到模型中，在所有控制器中都可以使用这些绑定的数据。
3. **全局数据预处理**：`@ControllerAdvice` 注解的类中还可以定义全局数据预处理逻辑，例如对请求参数进行预处理、验证或者转换，以确保数据的合法性和准确性。

总之，`@ControllerAdvice` 注解提供了一种统一管理和处理控制器的异常、数据绑定和数据预处理逻辑的机制，使得我们可以在一个地方集中处理控制器相关的逻辑，提高代码的可维护性和可读性。



**@ControllerAdvice注解后的类，是不是说明只要项目中出现了异常，都会跳到该类进行处理，即使没有显示调用该类**

是的，`@ControllerAdvice` 注解标注的类会全局拦截处理控制器（Controller）中抛出的异常，即使在代码中没有显式地调用该类。当控制器中抛出异常时，Spring 框架会自动检测到有 `@ControllerAdvice` 注解的类，并调用其中与异常类型匹配的异常处理方法。

`@ControllerAdvice` 注解的作用是统一处理控制器抛出的异常，它可以捕获所有控制器中抛出的异常，无需在每个控制器中都单独编写异常处理逻辑。这样可以提高代码的复用性和可维护性，同时也更符合面向切面编程（AOP）的思想。

因此，一旦项目中的控制器抛出了异常，Spring 框架会自动委托给 `@ControllerAdvice` 注解标注的类中的异常处理方法进行处理。



***假如说我在服务层抛出了一个自定义异常，也会隐式调用@ControllerAdvice 注解标注的类来处理异常吗***

是的，如果你在服务层抛出了一个自定义异常，而没有在服务层中捕获并处理该异常，那么该异常会被传递到控制器层，并最终由 `@ControllerAdvice` 注解标注的类中的异常处理方法进行处理。

`@ControllerAdvice` 注解标注的类可以全局性地拦截处理控制器层抛出的异常，包括控制器层调用服务层后抛出的异常。因此，如果你在服务层抛出了异常，而没有在服务层中进行处理，这个异常就会被传递到控制器层，并由 `@ControllerAdvice` 注解标注的类中的异常处理方法进行处理。

这种全局异常处理的机制使得你可以在一个地方集中处理整个应用程序中抛出的异常，而不需要在每个控制器中都编写异常处理逻辑，提高了代码的复用性和可维护性。



## Day3



### 5.7 JSR303校验

## Day5

什么是分布式文件系统： 把若干计算机通过网络连接起来，共同提供存储文件、访问文件的服务。

